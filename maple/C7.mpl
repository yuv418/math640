
# Linear code generated by generating matrix M=[v1, v2, ... vd]
# over GF(q) if the set of all linear combinations
# a1*v1A + ... + ad*vd
#
# q-ary (n,M,d) code n:=length of each code word
# M:=size of the code (a code is a subset of Fqn(q,n) GF(q)^n (it has q^n elements))
# d:=minimal distance
# q-ary linear [n,k,d] coe is (n, q^k, d)
# Hamming Code (2^r-1, 2^(2^r-r-1), 3)
# (7, 16, 3)
# (15, 2048, 3),

CV:=proc(S, n) local v,i:
    v:=[]:
    for i from 1 to n do
        if member(i, S) then
            v:=[op(v),1]
        else
            v:=[op(v),0]
        fi:
    od:
    return v:
end:

MinD:=proc(C) local i,j:
min( seq(seq(HD(C[i],C[j]),j=i+1..nops(C)), i=1..nops(C))):
 end:

BDtoC := proc(VD, n) local s, C:
    C:={seq(CV(s, n), s in BD)}:
    C:=C union subs({0=1, 1=0}, C):
    C union {[0$n]}:
end:

# Given a list of basis vectors it
LToC := proc(q, M) local n, k, C, i:
    k:=nops(M):
    n:=nops(M[1]):
    if k=1 then
        return {seq(i*M[1] mod q, i=0..q-1)}:
    fi:
    M1 := M[1..k-1]:
    C:=LtoC(q,M1):
    return {seq(seq(c+(i*M[k] mod q,i=0..q-1)),c in C)}:
end:

# minimal weight
MinW:=proc(q,M):
    n:=nops(M[1]):
    c:=LtoC(q,M):
    min(seq(HD(c,[0$n], c in C minus {[0$n]}))):
end:

#### end of old code
#start new code for C7.txt


Nei:=proc(q,c) local n,i,a:
n:=nops(c):
{seq(seq([op(1..i-1,c),a,op(i+1..n,c)], a=0..q-1) , i=1..n)}:
end:

#SP(q,c,t): the set of all vectors in Fqn(q,n) whose distance is <=t from c
SP := proc(q,c,t) local S,s,i:
    S:={c}:
    for i from 1 to t do
        S := S union {seq(op(Nei(q,s)), s in S)}
    end:
    S:
end:

HD:=proc(u,v) local i,co:
co:=0:
for i from 1 to nops(u) do
  if u[i]<>v[i] then
      co:=co+1:
  fi:
od:
co:
end:

GRC:=proc(q,n,d) local S,A,v:
A:=Fqn(q,n):
S:={}:
while A<>{} do:
 v:=A[1]:
 S:=S union {v}:
 A:=A minus SP(q,v,d-1):
od:
S:
end:


#NN(C,v), inputs a code C and (subset of Fqn) where n:=nops(v) finds
#the set of members C closest to v
NN:=proc(C, v) local i,rec,cha:
    cha := {C[1]}:
    rec := HD(v,C[1]):
    for i from 2 to nops(C) do
        if HD(v,C[i])<rec then
            cha := {C[i]}:
        elif HD(v, C[i])=rec then
            cha:=cha union {C[i]}:
        end:
    end:
    cha:
end:


DecodeT:=proc(q,n,C) local S,v,T:
    S:=Fqn(q,n):

    for v in S do
        T[v] := NN(C,v)[1]:
    od:

    op(T):
end:

LtoC:=proc(q,M) local n,k,C,c,i,M1:
option remember:
k:=nops(M):
n:=nops(M[1]):
if k=1 then
 RETURN({seq(i*M[1] mod q,i=0..q-1) }):
fi:
M1:=M[1..k-1]:
C:=LtoC(q,M1):
{seq(seq(c+i*M[k] mod q,i=0..q-1),c in C)}:
end:
#MinW(q,M): The minimal weight of the Linear code generated by M over GF(q)
MinW:=proc(q,M) local n,C,c:
n:=nops(M[1]):
C:=LtoC(q,M):

min( seq(HD(c,[0$n]), c in C minus {[0$n]} )):

end:

# GLC1(q,M,d) tries to add a new member to the current basis M out of the other vectors
# that still has minimum weight d - 1000 dollars to figure out
GLC1:=proc(q,M,d) local n,A,c,M1:
    n:=nops(M[1]):
    A:=Fqn(q,n) minus LtoC(q,M):
    for c in A do:
        M1 := [op(M),c]:
        if MinW(q,M1)=d then
            return M1:
        fi:
    od:
    FAIL:
end:

#GLC(q,n,d) inputs q and n and d (for minimum distance) greedily and randomly
#tries to get as large a linear code given a basis
GLC:=proc(q,n,d) local M:
    M:=[[1$d,0$(n-d)]]:
    M1:=GLC1(q,M,d):
    while M1<>FAIL do
        print(M1);
        M:=M1:
        M1:=GLC1(q,M,d):
    od:
    M:
end:

#SA(q,n,M) inputs a basis M of a linear [n,nops(M),d] code outputs Slepian's
#Standard Array as a matrix of vectors containing all the vectors in GF(q)^n
#
